// Exercise 1: Using Promise.race() for Fastest Response
// Imagine you're building a real-time weather dashboard that displays the weather data from
// multiple sources. You want to display the weather data from two different weather APIs, but
// you want to use the response from the fastest API to provide the most up-to-date information.
// Design an exercise where you fetch weather data from two different APIs using fetch(), and
// then use Promise.race() to determine which API responds first and display its weather data
// on your dashboard.

// ============================================================================================

// Exercise 2: Using Promise.resolve() for Initial Data
// You're working on a chat application where users can send messages in real-time. To provide
// a seamless experience, you want to show a welcome message to new users when they join a
// chat room. Create an exercise where you simulate a new user joining the chat room. Use
// Promise.resolve() to create a resolved promise that delivers a welcome message to the new
// user as soon as they enter the chat room.

// ============================================================================================

// Exercise 3: Using Promise.allSettled() for Multiple API Responses
// You're building a news aggregator app that gathers news articles from various sources.
// Your app fetches news data from different APIs, and sometimes the APIs might have errors
// or slow responses. Design an exercise where you fetch news articles from multiple APIs
// using fetch(). After fetching from all APIs, use Promise.allSettled() to handle all the
// responses, regardless of whether they succeeded or failed. You want to aggregate and display
// both successful and unsuccessful responses, along with relevant error messages.

// ============================================================================================
