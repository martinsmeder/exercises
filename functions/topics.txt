Functional Programming (use throughout the exercises):
    • Higher-order functions: Allow you to express complex operations in a 
      concise manner
    • Pure functions: Have no side-effects and always produce the same 
      output for the same input
    • Immutability: Data cannot be modified after it’s creation, which helps 
      avoid unexpected changes, making the program more predictable, easier 
      to test and understand, and efficient

===========================================================================

1. Function Scope and Nested Functions (Closures):
Begin with understanding function scope and nested functions. This provides 
the foundation for understanding closures.

===========================================================================

2. Higher-Order Functions: Callback Functions:
Move on to using higher-order functions with callback functions. This is a 
common entry point into functional programming.

===========================================================================

3. Function Chaining:
Explore function chaining, as it's a logical extension from higher-order 
functions. Understanding chaining will lead you to currying and composition.

===========================================================================

4. Currying:
Delve into currying, which is a technique used in functional programming. 
It's important to understand before moving to composition.

5. Function Composition:
Conclude with function composition. This is a more advanced topic that builds 
on currying and chaining.

6. Custom Higher-Order Functions:
Practice building your own higher-order functions. This can be interspersed 
with the other topics as well.